name: CI - Test & Lint

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  # First job: discovery - scopri quali servizi sono testabili
  discover:
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.discover.outputs.services }}
      services_count: ${{ steps.discover.outputs.count }}
    steps:
      - uses: actions/checkout@v4

      - name: Discover testable services
        id: discover
        run: |
          # Cerca tutti i servizi con requirements.txt e tests/
          services=()
          for service_dir in services/*/; do
            service_name=$(basename "$service_dir")
            if [ -f "$service_dir/requirements.txt" ] && [ -d "$service_dir/tests" ]; then
              services+=("\"$service_name\"")
            fi
          done

          if [ ${#services[@]} -eq 0 ]; then
            echo "Nessun servizio testabile trovato!"
            echo "services=[]" >> $GITHUB_OUTPUT
            echo "count=0" >> $GITHUB_OUTPUT
          else
            services_json="[$(IFS=,; echo "${services[*]}")]"
            echo "services=$services_json" >> $GITHUB_OUTPUT
            echo "count=${#services[@]}" >> $GITHUB_OUTPUT
            echo "âœ… Servizi trovati: $services_json"
          fi

  # Main test job
  test:
    runs-on: ubuntu-latest
    needs: discover

    # Skip se non ci sono servizi
    if: needs.discover.outputs.services != '[]'

    services:
      postgres:
        image: timescale/timescaledb:latest-pg15
        env:
          POSTGRES_DB: heimdall_test
          POSTGRES_USER: heimdall_user
          POSTGRES_PASSWORD: test_password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

      rabbitmq:
        image: rabbitmq:3.12-management-alpine
        env:
          RABBITMQ_DEFAULT_USER: guest
          RABBITMQ_DEFAULT_PASS: guest
        options: >-
          --health-cmd "rabbitmq-diagnostics -q ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5672:5672
          - 15672:15672

    strategy:
      matrix:
        python-version: ["3.11"]
        service: ${{ fromJson(needs.discover.outputs.services) }}
      fail-fast: false # Continua se un servizio fallisce

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Display service info
        run: |
          echo "ðŸ”§ Testing service: ${{ matrix.service }}"
          echo "ðŸ“ Python version: ${{ matrix.python-version }}"
          ls -la services/${{ matrix.service }}/

      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ matrix.service }}-${{ hashFiles('services/${{ matrix.service }}/requirements.txt', 'services/${{ matrix.service }}/requirements-*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ matrix.service }}-
            ${{ runner.os }}-pip-

      - name: Install base dependencies
        run: |
          python -m pip install --upgrade pip setuptools wheel
          pip install pytest pytest-cov pytest-asyncio pytest-timeout black ruff

      - name: Install service dependencies
        run: |
          cd services/${{ matrix.service }}
          echo "ðŸ“¦ Installing requirements from $(pwd)/requirements.txt"
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt --timeout=120
          else
            echo "âš ï¸ No requirements.txt found"
          fi

          # Installa anche requirements-test.txt se esiste
          if [ -f requirements-test.txt ]; then
            echo "ðŸ“¦ Installing test requirements"
            pip install -r requirements-test.txt --timeout=120
          fi

      - name: Format check with black
        continue-on-error: true # Non blocca se fallisce
        run: |
          cd services/${{ matrix.service }}
          if [ -d src ]; then
            echo "ðŸŽ¨ Checking code formatting with black..."
            black --check src/ 2>&1 || true
            echo "âš ï¸ Format issues found (not blocking)"
          else
            echo "â­ï¸ No src/ directory to format check"
          fi

      - name: Lint with ruff
        continue-on-error: true
        run: |
          cd services/${{ matrix.service }}
          if [ -d src ]; then
            echo "ðŸ” Linting with ruff..."
            ruff check src/ 2>&1 || echo "âš ï¸ Lint issues (not blocking)"
          else
            echo "â­ï¸ No src/ directory to lint"
          fi

      - name: Verify Python imports path configuration
        run: |
          cd services/${{ matrix.service }}

          # Verify conftest.py exists (should be committed in repo)
          if [ -f tests/conftest.py ]; then
            echo "âœ… conftest.py found for ${{ matrix.service }}"
          else
            echo "âš ï¸ WARNING: conftest.py not found for ${{ matrix.service }}"
            echo "This may cause import errors. Creating fallback conftest.py..."
            mkdir -p tests
            cat > tests/conftest.py << 'EOF'
import sys
from pathlib import Path

def pytest_configure(config):
    """Add src/ to Python path before tests run"""
    service_root = Path(__file__).parent.parent
    src_path = service_root / "src"
    if str(src_path) not in sys.path:
        sys.path.insert(0, str(src_path))
    if str(service_root) not in sys.path:
        sys.path.insert(0, str(service_root))
EOF
          fi

      - name: Test with pytest (unit tests only)
        timeout-minutes: 30
        env:
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432
          POSTGRES_DB: heimdall_test
          POSTGRES_USER: heimdall_user
          POSTGRES_PASSWORD: test_password
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          RABBITMQ_HOST: localhost
          RABBITMQ_PORT: 5672
          RABBITMQ_USER: guest
          RABBITMQ_PASS: guest
          TESTING: "true"
          LOG_LEVEL: "INFO"
        run: |
          cd services/${{ matrix.service }}
          echo "ðŸ§ª Running tests for ${{ matrix.service }}..."

          if [ ! -d tests ]; then
            echo "â­ï¸ No tests/ directory found"
            exit 0
          fi

          # Esegui unit tests, skippando E2E e test di connessione
          echo "ðŸ“‹ Running unit and integration tests..."
          pytest tests/ \
            -v \
            --tb=short \
            --timeout=300 \
            --cov=src/ \
            --cov-report=xml \
            --cov-report=term-missing \
            --cov-report=html \
            --ignore=tests/e2e \
            --deselect=tests/test_api_contracts.py::test_01_health_endpoint \
            -k "not e2e and not health_endpoint and not test_api_contracts" \
            -x 2>&1 | tee test_output.log

          exit_code=${PIPESTATUS[0]}

          if [ $exit_code -eq 0 ]; then
            echo "âœ… Tests passed for ${{ matrix.service }}"
          elif [ $exit_code -eq 5 ]; then
            echo "âš ï¸ No tests found for ${{ matrix.service }} (exit 5 = no tests)"
            exit 0  # Non Ã¨ un errore se non ci sono test
          else
            echo "âŒ Tests FAILED for ${{ matrix.service }} (exit code: $exit_code)"
            exit $exit_code
          fi

      - name: Generate coverage report
        if: always()
        continue-on-error: true
        run: |
          cd services/${{ matrix.service }}
          if [ -f coverage.xml ]; then
            echo "ðŸ“Š Coverage report generated"
            cat coverage.xml | head -20
          fi

      - name: Upload coverage to Codecov
        if: always()
        uses: codecov/codecov-action@v3
        with:
          files: services/${{ matrix.service }}/coverage.xml
          flags: ${{ matrix.service }}
          name: coverage-${{ matrix.service }}
          fail_ci_if_error: false

  # Job finale: riassunto con FAIL corretto
  test-summary:
    runs-on: ubuntu-latest
    needs: [discover, test]
    if: always()

    steps:
      - name: Calculate test results
        id: results
        run: |
          echo "Services tested: ${{ needs.discover.outputs.services_count }}"
          echo "Test job result: ${{ needs.test.result }}"

          # Se test Ã¨ fallito, fallisci anche il summary
          if [ "${{ needs.test.result }}" != "success" ] && [ "${{ needs.discover.outputs.services_count }}" != "0" ]; then
            echo "status=FAILED" >> $GITHUB_OUTPUT
            echo "âŒ TESTS FAILED - CI workflow will fail"
            exit 1
          else
            echo "status=PASSED" >> $GITHUB_OUTPUT
            echo "âœ… ALL TESTS PASSED"
            exit 0
          fi

      - name: Final status
        if: always()
        run: |
          if [ "${{ steps.results.outputs.status }}" == "FAILED" ]; then
            echo "ðŸ”´ CI FAILED - Please fix test failures above"
            exit 1
          else
            echo "ðŸŸ¢ CI PASSED - All tests successful"
            exit 0
          fi
