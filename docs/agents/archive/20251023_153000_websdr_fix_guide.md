# WebSDR Connectivity Fix - Implementation Guide

## Problem Statement

The WebSDR health check endpoints were not working properly, preventing the frontend from querying the status of WebSDR receivers. The issues were:

1. **Empty WebSDR list in health check**: The `health_check_websdrs` Celery task had an empty `websdrs = []` list
2. **Missing API Gateway routing**: The API Gateway wasn't proxying requests to the rf-acquisition service
3. **Type mismatch**: Backend response format didn't match frontend TypeScript interface expectations

## Solution Overview

### 1. Backend Fix (rf-acquisition service)

#### File: `services/rf-acquisition/src/tasks/acquire_iq.py`

**Before:**
```python
@shared_task(bind=True)
def health_check_websdrs(self):
    # TODO: Load WebSDR configs from database
    websdrs = []  # ❌ Empty list!
    
    async def check():
        async with WebSDRFetcher(websdrs=websdrs) as fetcher:
            return await fetcher.health_check()
    ...
```

**After:**
```python
@shared_task(bind=True)
def health_check_websdrs(self):
    from ..routers.acquisition import get_websdrs_config
    
    # ✅ Load actual WebSDR configs
    websdrs_config_list = get_websdrs_config()
    websdrs = [WebSDRConfig(**cfg) for cfg in websdrs_config_list]
    
    if not websdrs:
        logger.warning("No WebSDRs configured for health check")
        return {}
    
    async def check():
        async with WebSDRFetcher(websdrs=websdrs) as fetcher:
            return await fetcher.health_check()
    ...
```

#### File: `services/rf-acquisition/src/routers/acquisition.py`

**Before:**
```python
@router.get("/websdrs/health")
async def check_websdrs_health():
    task = health_check_websdrs.delay()
    result = task.get(timeout=60)
    
    # ❌ Simplified format, raises HTTPException on error
    health_status = {}
    for ws_config in websdrs_config:
        ws_id = ws_config['id']
        health_status[ws_id] = {
            'id': ws_id,
            'name': ws_config['name'],
            'status': 'online' if result.get(ws_id, False) else 'offline'
        }
    
    return health_status
```

**After:**
```python
@router.get("/websdrs/health")
async def check_websdrs_health():
    try:
        task = health_check_websdrs.delay()
        result = task.get(timeout=60)
        
        # ✅ Detailed format matching frontend expectations
        health_status = {}
        check_time = datetime.utcnow().isoformat()
        
        for ws_config in websdrs_config:
            ws_id = ws_config['id']
            is_online = result.get(ws_id, False)
            
            health_status[ws_id] = {
                'websdr_id': ws_id,
                'name': ws_config['name'],
                'status': 'online' if is_online else 'offline',
                'last_check': check_time,
            }
            
            if not is_online:
                health_status[ws_id]['error_message'] = 'Health check failed or timed out'
        
        return health_status
    
    except Exception as e:
        # ✅ Graceful error handling - return offline status instead of 500
        websdrs_config = get_websdrs_config()
        check_time = datetime.utcnow().isoformat()
        
        health_status = {}
        for ws_config in websdrs_config:
            health_status[ws_config['id']] = {
                'websdr_id': ws_config['id'],
                'name': ws_config['name'],
                'status': 'offline',
                'last_check': check_time,
                'error_message': f'Health check error: {str(e)}'
            }
        
        return health_status
```

### 2. API Gateway Implementation

#### File: `services/api-gateway/src/main.py`

Added complete HTTP proxying functionality:

```python
import httpx

# Service URLs
RF_ACQUISITION_URL = "http://rf-acquisition:8001"
INFERENCE_URL = "http://inference:8002"
TRAINING_URL = "http://training:8003"
DATA_INGESTION_URL = "http://data-ingestion-web:8004"

async def proxy_request(request: Request, target_url: str):
    """Proxy HTTP request to backend service."""
    # Build full target URL with path and query
    path = request.url.path
    query = str(request.url.query)
    full_url = f"{target_url}{path}"
    if query:
        full_url = f"{full_url}?{query}"
    
    # Get request body if present
    body = None
    if request.method in ["POST", "PUT", "PATCH"]:
        body = await request.body()
    
    # Forward headers (excluding host)
    headers = dict(request.headers)
    headers.pop('host', None)
    
    async with httpx.AsyncClient(timeout=30.0) as client:
        response = await client.request(
            method=request.method,
            url=full_url,
            headers=headers,
            content=body,
        )
        
        return JSONResponse(
            content=response.json() if response.text else {},
            status_code=response.status_code,
            headers=dict(response.headers)
        )

# Route definitions
@app.api_route("/api/v1/acquisition/{path:path}", methods=["GET", "POST", "PUT", "DELETE", "PATCH"])
async def proxy_to_rf_acquisition(request: Request, path: str):
    return await proxy_request(request, RF_ACQUISITION_URL)
```

### 3. Dockerfile SSL Fixes

Both `services/rf-acquisition/Dockerfile` and `services/api-gateway/Dockerfile`:

**Before:**
```dockerfile
FROM python:3.11-slim as builder
WORKDIR /build
RUN apt-get update && apt-get install -y gcc postgresql-client
COPY requirements.txt .
RUN pip install --user --no-cache-dir -r requirements.txt
```

**After:**
```dockerfile
FROM python:3.11-slim as builder
WORKDIR /build
RUN apt-get update && apt-get install -y gcc postgresql-client ca-certificates
COPY requirements.txt .
RUN pip install --upgrade pip && \
    pip install --user --no-cache-dir \
    --trusted-host pypi.org \
    --trusted-host files.pythonhosted.org \
    -r requirements.txt
```

## Testing

### Automated Test Script

Run `test_websdr_fix.py`:

```bash
python3 test_websdr_fix.py
```

Expected output:
```
============================================================
WebSDR Connectivity Fix - Verification Tests
============================================================

Testing WebSDR list endpoint (direct)...
✓ Direct endpoint returns 7 WebSDRs

Testing WebSDR list endpoint (via API Gateway)...
✓ API Gateway proxy returns 7 WebSDRs

Testing WebSDR health endpoint (direct)...
✓ Direct health check returns proper format for all 7 WebSDRs

Testing WebSDR health endpoint (via API Gateway)...
✓ API Gateway health proxy returns status for all 7 WebSDRs

Sample WebSDR status:
{
  "websdr_id": 1,
  "name": "Aquila di Giaveno",
  "status": "offline",
  "last_check": "2025-10-22T15:42:26.663760",
  "error_message": "Health check failed or timed out"
}

============================================================
Tests completed: 4 passed, 0 failed
============================================================
```

### Manual Testing

1. **Test WebSDR list endpoint:**
```bash
# Direct to rf-acquisition
curl http://localhost:8001/api/v1/acquisition/websdrs | jq

# Via API Gateway
curl http://localhost:8000/api/v1/acquisition/websdrs | jq
```

2. **Test WebSDR health endpoint:**
```bash
# Direct to rf-acquisition
curl http://localhost:8001/api/v1/acquisition/websdrs/health | jq

# Via API Gateway
curl http://localhost:8000/api/v1/acquisition/websdrs/health | jq
```

## Response Format

### WebSDR List Response

```json
[
  {
    "id": 1,
    "name": "Aquila di Giaveno",
    "url": "http://sdr1.ik1jns.it:8076/",
    "location_name": "Giaveno, Italy",
    "latitude": 45.02,
    "longitude": 7.29,
    "is_active": true,
    "timeout_seconds": 30,
    "retry_count": 3
  },
  ...
]
```

### WebSDR Health Response

```json
{
  "1": {
    "websdr_id": 1,
    "name": "Aquila di Giaveno",
    "status": "offline",
    "last_check": "2025-10-22T15:42:26.663760",
    "error_message": "Health check failed or timed out"
  },
  "2": {
    "websdr_id": 2,
    "name": "Montanaro",
    "status": "online",
    "last_check": "2025-10-22T15:42:26.663760"
  },
  ...
}
```

## Frontend Integration

The frontend can now query WebSDR status using:

```typescript
import webSDRService from '@/services/api/websdr';

// Get all WebSDRs
const websdrs = await webSDRService.getWebSDRs();

// Check health status
const healthStatus = await webSDRService.checkWebSDRHealth();

// Example usage
healthStatus[1].status // 'online' | 'offline'
healthStatus[1].name   // 'Aquila di Giaveno'
healthStatus[1].last_check // ISO timestamp
```

## Deployment

### Docker Compose

```bash
# Build services
docker compose build rf-acquisition api-gateway

# Start services
docker compose up -d rf-acquisition api-gateway

# Verify
docker compose ps
docker logs heimdall-rf-acquisition | grep "health"
docker logs heimdall-api-gateway
```

### Kubernetes

Update Helm values to ensure:
1. API Gateway routes are configured
2. Service discovery between gateway and rf-acquisition works
3. Health check probes are properly configured

## Known Limitations

1. **WebSDR Status in Test Environments**: WebSDRs will show as "offline" in environments without external internet access or where the WebSDR URLs are not reachable.

2. **Health Check Timeout**: The health check has a 60-second timeout. With 7 WebSDRs and 10-second individual timeouts, this should be sufficient but may need adjustment if WebSDRs are slow to respond.

3. **No Caching**: Health check results are not cached. Consider implementing Redis caching if frequent checks become a performance issue.

## Future Enhancements

1. **Redis Caching**: Cache health check results for 30-60 seconds to reduce load
2. **Background Health Checks**: Run health checks in background and serve cached results
3. **WebSDR Database Storage**: Move WebSDR configuration from hardcoded list to database
4. **Health Check Metrics**: Track historical uptime and reliability per WebSDR
5. **WebSocket Updates**: Push real-time health status changes to frontend

## Troubleshooting

### Issue: All WebSDRs show as offline

**Cause**: WebSDR URLs are not accessible from the deployment environment.

**Solution**: 
- Check network connectivity from the container
- Verify WebSDR URLs are correct and accessible
- Check firewall rules
- Test with `curl` from within the rf-acquisition container:
  ```bash
  docker exec heimdall-rf-acquisition curl -I http://sdr1.ik1jns.it:8076/
  ```

### Issue: API Gateway returns 503 Service Unavailable

**Cause**: rf-acquisition service is not running or not accessible.

**Solution**:
- Check service is running: `docker compose ps rf-acquisition`
- Check logs: `docker logs heimdall-rf-acquisition`
- Verify network connectivity: `docker network inspect heimdall_heimdall-network`

### Issue: Health check times out

**Cause**: One or more WebSDRs are very slow to respond.

**Solution**:
- Increase timeout in `/api/v1/acquisition/websdrs/health` endpoint
- Implement background health checks with cached results
- Reduce individual WebSDR timeout from 10 to 5 seconds

## References

- WebSDR Configuration: `WEBSDRS.md`
- API Documentation: `docs/API.md`
- Architecture: `docs/ARCHITECTURE.md`
- Phase 3 Completion: `PHASE3_COMPLETE_SUMMARY.md`
